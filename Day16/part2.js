let content = '59787832768373756387231168493208357132958685401595722881580547807942982606755215622050260150447434057354351694831693219006743316964757503791265077635087624100920933728566402553345683177887856750286696687049868280429551096246424753455988979991314240464573024671106349865911282028233691096263590173174821612903373057506657412723502892841355947605851392899875273008845072145252173808893257256280602945947694349746967468068181317115464342687490991674021875199960420015509224944411706393854801616653278719131946181597488270591684407220339023716074951397669948364079227701367746309535060821396127254992669346065361442252620041911746738651422249005412940728';
//content = '12345678';
//content = '80871224585914546619083218645595';
//content = '03036732577212944063491565474664';
//content = '1234';
const CONTENT_REPLICATIONS = 10000;

// Repeat content
let input = '';
for(let i=0; i<CONTENT_REPLICATIONS; i++) input += content;
const offset = Number(input.substring(0,7));

// Discard all digits more significant than the offset
input = input.substring(offset).split('').map(Number);

let phase = 0;
let newDigits = new Array(input.length);

while (phase < 100) {
    let sum = 0;

    // Iterate from least significant digit to most
    for (let i=input.length-1; i>=0; i--) {
        // Co-efficient will always be 1 for large offsets
        sum = (sum + input[i]) % 10;

        // We can safely set this digit as it won't be affected by 'larger' numbers
        newDigits[i] = sum;
    }

    input = newDigits;
    phase++;
}

console.log(input.slice(0, 8).join(''));